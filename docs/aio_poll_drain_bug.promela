/*
 * Demonstrate the behavior of blk_drain() when called from the
 * iothread.
 *
 * Author: Paolo Bonzini <pbonzini@redhat.com>
 *
 * This file is in the public domain.  If you really want a license,
 * the WTFPL will do.
 *
 * To simulate it:
 *     spin -p docs/aio_poll_sync_io.promela
 *
 * To verify it:
 *     spin -a docs/aio_poll_sync_io.promela
 *     gcc -O2 pan.c -DSAFETY
 *     ./a.out
 *
 * Note that the model verifies successfully, but it is actually buggy.
 * The reason is that the bottom half structure in the iothread is
 * overly simplified.
 *
 * This explains why blk_drain() needs to use non-blocking aio_poll,
 * for whose modeling see aio_poll_drain.promela.
 */

#define REQS         3
#define REQS_INITIAL 1

int req_submitted = 0;
int req_completed = 0;
int req_pending   = 0;


/* This is a mutex.  */
int mutex = 0;
#define LOCK(mutex)   atomic { mutex == 0 -> mutex = 1; }
#define UNLOCK(mutex) mutex = 0

/* A QEMUBH (e.g. from thread-pool.c) */
bool io_bh_scheduled;

/* The AioContext's EventNotifier */
bool aio_notify;

/* The AioContext's QemuEvent.  Typically the first call to aio_poll
 * produces a spurious wakeup.  In aio_poll_drain.promela, the
 * initializers are set to 1 to model this.  This model is buggy
 * so we skip this additional torture...
 */
bool progress;
bool sync_io_event;

proctype io_worker(int req_id)
{
    LOCK(mutex);
        req_completed++;
    UNLOCK(mutex);

    io_bh_scheduled = 1;
    aio_notify = 1;
}

#define SUBMIT_ONE_REQ {                         \
       run io_worker(req_submitted);             \
       req_submitted++;                          \
       req_pending++;                            \
    }

active proctype iothread()
{
    bool old;
    bool aio_poll_progress;

    /* The iothread keeps calling aio_poll(..., true).  At the end
     * of the simulation it is stuck here waiting for a request,
     * so mark this as a valid end state.
     */
end:
    do
        :: aio_notify -> {
            /* aio_notify_accept */
            aio_notify = 0;

            aio_poll_progress = 0;

            atomic { old = io_bh_scheduled; io_bh_scheduled = 0; }
            if
                :: old -> {
                    LOCK(mutex);
                        req_pending = req_pending - req_completed;
                        req_completed = 0;
                        assert(req_pending >= 0);

                        if
                           :: req_submitted < REQS -> SUBMIT_ONE_REQ
                           :: else                 -> skip;
                        fi;
                    UNLOCK(mutex);
                    aio_poll_progress = 1;
                }
                :: else -> skip;
            fi;

            /* The above is aio_poll_internal, this is aio_poll */
            if
                :: aio_poll_progress -> progress = 1;
                :: else -> skip;
            fi;
            sync_io_event = 1;
        }
    od;
}

#define AIO_POLL_ITERATION             \
    if                                 \
        :: sync_io_event -> skip;      \
    fi;                                \
    sync_io_event = 0;                 \
    atomic {                           \
        aio_poll_result = aio_poll_result | progress;    \
        progress = 0;                  \
    }

#define AIO_POLL                       \
    aio_poll_result = 0;               \
    AIO_POLL_ITERATION

active proctype mainthread()
{
    bool aio_poll_result;
    bool busy = true;

    LOCK(mutex);
        /* Start with a few requests */
        do
           :: req_submitted < REQS_INITIAL -> SUBMIT_ONE_REQ
           :: else                         -> break;
        od;
    UNLOCK(mutex);

    do
        :: true -> {
            /* This is blk_drain */
            LOCK(mutex);
                busy = req_pending > 0;
            UNLOCK(mutex);
            if
               :: busy -> AIO_POLL;
               :: else -> break;
            fi;
        }
    od;

    LOCK(mutex);
        assert(!req_pending && req_submitted == REQS);
    UNLOCK(mutex);
}

